# !/usr/bin python3
# -*- encoding:utf-8 -*-
# @Author : Samzhang
# @File : etf1.11.py
# @Time : 2022/1/11 6:56
"""
当日买入，次日见利就分3批次卖出

如果yes1_highest > yes2_highest, yes1_lowest > yes2_lowest 直接加速卖出清仓
加入top判断，如果出现top，不买且卖
加入macd判断，小于0.008 绝对不能买
买入不看yes1_highest > yes2_highest, yes1_lowest > yes2_lowest ，增加买入量!!!
卖出看

设置总仓位20万，通过总仓位控制per_top_money,尽量打满仓位

调整整体回测形式，一天一天的回测，这样才能更好仿真到真实的打满仓位

"""

import requests as req
import httpx
import asyncio
import re
import pandas as pd
import time
import tushare as ts
import pymongo as pm
from multiprocessing import Process
from multiprocessing import Queue
import pyautogui as pg
from selenium import webdriver
import tkinter as tk
import math
import random
import os
import datetime
from urllib3.util.retry import Retry
from requests.adapters import HTTPAdapter
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.chrome.options import Options
# from proxy_url import Proxy_url
from logger import *
import talib
import numpy


class ETF:
    def __init__(self, yestoday, today):
        # 设置交易时间
        self.today = today
        self.yestoday = yestoday

        # 获取当前执行文件的名称
        self.file_name = str(os.path.basename(__file__).split('.')[0])
        # 设置日志记录位置
        self.logger = Logger('./' + self.file_name + '.log')

        # 连接mongoDB
        self.myclient = pm.MongoClient("mongodb://localhost:27017/")
        self.fd = self.myclient["freedom"]

        self.trade_rec = self.fd[self.file_name + 'trade_rec']
        self.yesBuy = self.fd[self.file_name + 'yesBuy' + self.yestoday]
        self.hasBuy = self.fd[self.file_name + 'hasBuy']

        self.all_etf_jklist = [i['code'] for i in self.fd['all_etf_jklist_backtest'].find()]

        self.allList = self.fd['all_etf_jklist_backtest']

        # 设置ip池
        self.ipPool = self.fd['ipPool']
        self.allIpPool = self.fd['allIpPool']

        # 捕捉最低和最高价格临时记录字典变量
        self.catch_lowest = {}
        self.catch_highest = {}
        # 临时存储极值
        self.lowest_price = {}
        self.highest_price = {}

        # 获取当日交易的股票代码
        for j in self.all_etf_jklist:
            self.catch_lowest[j] = pd.Series()
            self.catch_highest[j] = pd.Series()

            self.lowest_price[j] = 1000
            self.highest_price[j] = 0

        # 获取当日要卖的股票代码
        # yb = self.trade_rec.find()
        # for y in self.all_etf_jklist:
        #     self.catch_highest[y['code']] = pd.Series()

        self.isAppear_top = False


        self.logger = self.getlogger()

        self.total_yingkui_money = 0
        yingkui_res = self.trade_rec.find()
        if yingkui_res:
            for r in yingkui_res:
                self.total_yingkui_money += r['yingkui']

        self.trands_top_money = 250000 + int(self.total_yingkui_money/1000) * 1000

        # self.all_top_money = 20000 + int(self.total_yingkui_money/1000) * 1000
        self.per_top_money = self.trands_top_money/100
        # 设置最大仓位
        self.all_top_money = 200000
        # self.top_cangwei1 = self.all_top_money * 0.3
        # self.top_cangwei2 = self.all_top_money * 0.5
        self.top_cangwei3 = self.all_top_money * 0.7
        self.top_cangwei4 = self.all_top_money * 0.9

    def getlogger(self):
        self.logger = logging.getLogger("logger")
        # 判断是否有处理器，避免重复执行
        if not self.logger.handlers:
            # 日志输出的默认级别为warning及以上级别，设置输出info级别
            self.logger.setLevel(logging.DEBUG)
            # 创建一个处理器handler  StreamHandler()控制台实现日志输出
            sh = logging.StreamHandler()
            # 创建一个格式器formatter  （日志内容：当前时间，文件，日志级别，日志描述信息）
            formatter = logging.Formatter('[%(asctime)s] [%(levelname)s] [%(lineno)d line]: %(message)s')

            # 创建一个文件处理器，文件写入日志
            fh = logging.FileHandler(filename='./trading_' + str(self.file_name) + '.log', encoding="utf8")
            # 创建一个文件格式器f_formatter
            f_formatter = logging.Formatter(fmt="[%(asctime)s] [%(levelname)s] [%(lineno)d line]: %(message)s",
                                            datefmt="%Y/%m/%d %H:%M:%S")

            # 关联控制台日志器—处理器—格式器
            self.logger.addHandler(sh)
            sh.setFormatter(formatter)
            # 设置处理器输出级别
            sh.setLevel(logging.INFO)

            # 关联文件日志器-处理器-格式器
            self.logger.addHandler(fh)
            fh.setFormatter(f_formatter)
            # 设置处理器输出级别
            fh.setLevel(logging.DEBUG)

        return self.logger

    def get_ma(self, code_df):

        # 获取历史交易的收盘价，最高价格，最低价，用于计算均价
        self.code_df = code_df
        self.yes2_ma5 = round(self.code_df[self.code_df['date'] <= self.yestoday].iloc[-6:-1]['close'].mean(), 4)
        self.yes1_ma5 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(5)['close'].mean(), 4)
        self.yes1_ma4 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(4)['close'].mean(), 4)
        self.yes2_ma4 = round(self.code_df[self.code_df['date'] <= self.yestoday].iloc[-5:-1]['close'].mean(), 4)
        self.sum_ma4 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(4)['close'].sum(), 4)
        self.sum_ma5 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(5)['close'].sum(), 4)
        self.sum_ma6 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(6)['close'].sum(), 4)
        self.sum_ma7 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(7)['close'].sum(), 4)
        self.ma10 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(10)['close'].mean(), 4)
        self.yes1_ma6 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(6)['close'].mean(), 4)
        self.yes2_ma6 = round(self.code_df[self.code_df['date'] <= self.yestoday].iloc[-7:-1]['close'].mean(), 4)
        self.yes1_ma7 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(7)['close'].mean(), 4)
        self.yes2_ma7 = round(self.code_df[self.code_df['date'] <= self.yestoday].iloc[-8:-1]['close'].mean(), 4)
        self.yes1_ma8 = round(self.code_df[self.code_df['date'] <= self.yestoday].tail(8)['close'].mean(), 4)
        self.yes2_ma8 = round(self.code_df[self.code_df['date'] <= self.yestoday].iloc[-9:-1]['close'].mean(), 4)
        self.yes1_close = self.code_df[self.code_df['date'] <= self.yestoday].tail(2)['close'].iloc[1]
        self.yes2_close = self.code_df[self.code_df['date'] <= self.yestoday].tail(2)['close'].iloc[0]
        self.yes1_lowest = self.code_df[self.code_df['date'] <= self.yestoday].tail(2)['lowest'].iloc[1]
        self.yes2_lowest = self.code_df[self.code_df['date'] <= self.yestoday].tail(2)['lowest'].iloc[0]
        self.yes1_highest = self.code_df[self.code_df['date'] <= self.yestoday].tail(2)['highest'].iloc[1]
        self.yes2_highest = self.code_df[self.code_df['date'] <= self.yestoday].tail(2)['highest'].iloc[0]

        # 获取到昨日macd数据
        self.new_df = pd.DataFrame()
        self.new_df['date'] = self.code_df[self.code_df['date'] <= self.yestoday]['date']
        self.new_df['dif'], self.new_df['dea'], self.new_df['dw'] = talib.MACD(
            self.code_df[self.code_df['date'] <= self.yestoday]['close'].values, 3, 8, 5)
        self.new_df['macd'] = (self.new_df['dif'] - self.new_df['dea']) * 2
        self.yes1_macd = self.new_df['macd'].values[-1]
        self.yes2_macd = self.new_df['macd'].values[-2]

    # 修改代码类型
    def chg_code_type(self, code):
        if code[7:9] == 'SZ':
            code = 'sz' + code[0:6]
        elif code[7:9] == 'SH':
            code = 'sh' + code[0:6]
        elif code[0:3] == '000' or code[0:3] == '002':
            code = 'sz' + code[0:6]
        elif code[0] == '6':
            code = 'sh' + code[0:6]
        return code

    # 获取基础成交数据
    def get_basic_data(self):
        """
        #         continue
        #         print(data.columns)
        #         try:
        #             # print(data['datetime'].str.contains('2021-07-30'))
        #             # print(data[['datetime','SZSE.'+c[2:]+'.last_price','SZSE.'+c[2:]+'.highest','SZSE.'+c[2:]+'.lowest']])
        #             # print(data[['datetime','SZSE.'+c[2:]+'.last_price','SZSE.'+c[2:]+'.highest','SZSE.'+c[2:]+'.lowest']].where(data['datetime'].str.contains('2021-07-30')))
        #             # print('数据长度',len(data))
        #             # print(file_path)
        #             print(data['datetime'].str.slice(0,10))
        #             print(data['datetime'].str.slice(0,10).drop_duplicates())
        #             print(data['datetime'].str.slice(0,10).groupby(axis=2))
        #             print(data.groupby(by = 'datetime'))
        #             exit()
        #         except Exception as e:
        #             print(e)
        # # data = pd.read_csv('./data/7/'+c[2:]+'.csv')
        # # print(data.head(1))
        # # data = pd.read_csv('./data/7/512100.csv')
        # # print(data.columns)
        # # for d in data.itertuples():
        # #     print(d[1],'-->',d[3])
        #
        # # print(data)
        # """

    def jk_buy(self, curr_time, ser, lastreq):
        if curr_time.hour >= 9 and curr_time.hour < 15:
            if (curr_time.hour == 11 and curr_time.minute > 30) or curr_time.hour == 12:
                pass
            elif (curr_time.hour == 9 and curr_time.minute >= 30) or curr_time.hour >= 10:
                # if 1:
                #     if 1:
                try:
                    pass
                    # 设置买入动作起始位置
                    btfrom = 1

                    # 获取市场行情，进行交易评级quotation
                    # pct_sh, pct_sz = self.dp()
                    # qttA = 0.65
                    # qttB = 0.5
                    # qttC = 0.35
                    # qttD = 0.2

                    # print('-------------------------------jk买第', n, '次', '--上证指数：', round(pct_sh, 2), '--深证指数:',
                    #       round(pct_sz, 2), '---------------------------')
                except Exception as e:
                    print('jkRedProcess错误1', e)
                    raise (e)
                else:
                    try:
                        # self.catch_lowest方式
                        for k, v in ser.iteritems():

                            # 判断当前价格是否低于最低价格，如果低于最低价格，那么清空该字典，然后再插入最低价,并从最低价开始记录
                            today_lowest = lastreq['today_lowest']
                            curr_price = lastreq['curr_price']

                            # 抓捕当日最低价格
                            # if v == today_lowest:
                            #     self.catch_lowest[k] = pd.Series()

                            if self.lowest_price[k] > today_lowest:
                                self.lowest_price[k] = today_lowest
                                self.catch_lowest[k] = pd.Series()
                                self.catch_lowest[k][curr_time] = today_lowest
                                self.logger.info(f"lowest_point!!!: {self.lowest_price[k]}")
                            else:
                                self.catch_lowest[k][curr_time] = v

                            if curr_price == 0:
                                continue

                            # 计算当前ma5
                            curr_ma5 = (self.sum_ma4 + curr_price) / 5
                            curr_ma6 = (self.sum_ma5 + curr_price) / 6
                            curr_ma7 = (self.sum_ma6 + curr_price) / 7
                            curr_ma8 = (self.sum_ma7 + curr_price) / 8

                            # if self.yes2_ma5 > self.yes1_ma5 and self.yes1_ma5 > curr_ma5:
                            #     # self.logger.warning('jk_buy:下跌趋势， ' + ' yes2_ma5：' + str(self.yes2_ma5) + ' yes_ma5:' + str(self.yes1_ma5) +' curr_ma5:'+ str(curr_ma5) + ' ma10:' + str(self.ma10))
                            #     continue

                            self.beili = self.fd[self.file_name + '_beili']

                            # 设置交易金额
                            # 获取当日total_nosale
                            # self.total_nosale_money = 0
                            # res = self.trade_rec.find({'isSold': 0, 'code': k})
                            # for r in res:
                            #     self.total_nosale_money += (r['left_num'] * r['cost'])

                            # 根据总仓位来确定per_top_money,随着trade_days增加而减少
                            # if all_buy_money/self.all_top_money <= 0.35:
                            #     per_top_money = 80000
                            # elif all_buy_money/self.all_top_money <= 0.6:
                            #     per_top_money = 50000
                            # elif all_buy_money/self.all_top_money <= 0.8:
                            #     per_top_money = 30000
                            # elif all_buy_money/self.all_top_money <= 0.9:
                            #     per_top_money = 10000
                            # else:
                            #     per_top_money = 5000

                            # per_top_money = (self.all_top_money - all_buy_money)
                            # per_top_money = self.per_top_money
                            # if per_top_money <= 0:
                            #     per_top_money = 0

                            # 如果是亏损，那么就用固定per_top_money
                            # yingkui_info = self.fd[self.file_name + 'noSale_money'].find_one(
                            #     {'code': k, 'date': self.yestoday})
                            # if yingkui_info and yingkui_info['yingkui'] <= 0:
                            #     per_top_money = 8000

                            # 获取最近插入的数据
                            latest_rec = self.beili.find({'code': k}).sort('_id', -1).limit(1)
                            latest_rec = [x for x in latest_rec]

                            # 当日如果有记录背离，那么查看是否有变动的，有变动则清除掉背离
                            rec_code = self.beili.find_one({'code': k, 'date': self.today})
                            if rec_code and curr_price < self.yes1_ma8 and rec_code['type'] == 'bottom':
                                self.beili.delete_one({'code': k, 'date': self.today, 'type': 'bottom'})
                                self.logger.warning(f"delete_bottom:'code':{k}, 'date':{self.today}, 'type':'bottom'")
                            elif rec_code and curr_price > self.yes1_ma8 * 1.006 and rec_code['type'] == 'top':
                                self.beili.delete_one({'code': k, 'date': self.today, 'type': 'top'})
                                self.logger.warning(f"delete_top:'code':{k}, 'date':{self.today}, 'type':'top'")

                            cond1 = (self.yes2_close >= self.yes1_close or self.yes2_lowest >= self.yes1_lowest or self.yes2_highest >= self.yes1_highest or self.yes1_lowest > curr_price)
                            cond2 = self.yes1_ma8 > curr_price or self.yes1_ma7 > curr_price
                            cond3 = (self.yes1_ma7 > self.yes2_ma7 or self.yes1_ma6 > self.yes2_ma6 or self.yes1_ma8 > self.yes2_ma8) or \
                                    (self.yes1_ma7 < curr_ma7 or self.yes1_ma6 < curr_ma6 or self.yes1_ma8 < curr_ma8)

                            if cond1 and cond2 and cond3:
                                beili_count_today_top = self.beili.count_documents(
                                    {'code': k, 'date': self.today, 'type': 'top'})

                                # 当天没有插入过，且最近一次的插入不是top，如果第一次插入，则可以插入
                                if beili_count_today_top == 0:
                                    if (latest_rec and latest_rec[0]['type'] != 'top'):
                                        self.isAppear_top = True
                                        self.beili.insert(
                                            {'code': k, 'type': 'top', 'price': curr_price, 'trade_state': 'out',
                                             'trade_days': 0, 'date': self.today, 'time': str(curr_time.time())})
                                        self.logger.info(f"latest_rec:{latest_rec}")
                                        self.logger.info(
                                            f"insert_top: code:{k}, 'date':{self.today},'curr_time:'{curr_time.time()}, 'type':top, 'curr_price':{curr_price}, 'yes2_close':{self.yes2_close}, 'yes1_close':{self.yes1_close}, 'ma10':{self.ma10}, 'ma8':{self.yes1_ma8}, 'ma7':{self.yes1_ma7}, 'ma6':{self.yes1_ma6} ")
                                    elif not latest_rec:
                                        self.isAppear_top = True
                                        self.beili.insert(
                                            {'code': k, 'type': 'top', 'price': curr_price, 'trade_state': 'out',
                                             'trade_days': 0, 'date': self.today, 'time': str(curr_time.time())})
                                        self.logger.info(
                                            f"insert_top: code:{k}, 'date':{self.today},'curr_time:'{curr_time.time()}, 'type':top, 'curr_price':{curr_price}, 'yes2_close':{self.yes2_close}, 'yes1_close':{self.yes1_close}, 'ma10':{self.ma10}, 'ma8':{self.yes1_ma8}, 'ma7':{self.yes1_ma7}, 'ma6':{self.yes1_ma6} ")

                            # 判断是否底背离
                            if (self.yes2_close <= self.yes1_close or self.yes2_lowest <= self.yes1_lowest or self.yes2_highest <= self.yes1_highest) and self.yes1_ma8 < curr_price and (
                                    self.yes1_ma7 < self.yes2_ma7 or self.yes1_ma6 < self.yes2_ma6 or self.yes1_ma8 < self.yes2_ma8):
                                beili_count = self.beili.count_documents(
                                    {'code': k, 'date': self.today, 'type': 'bottom'})

                                beili_count_today_bottom = self.beili.count_documents(
                                    {'code': k, 'date': self.today, 'type': 'bottom'})
                                beili_count_today_top = self.beili.count_documents(
                                    {'code': k, 'date': self.today, 'type': 'top'})
                                beili_count_yestoday_top = self.beili.count_documents(
                                    {'code': k, 'date': self.yestoday, 'type': 'top'})
                                # 当天没有插入过，且最近一次的插入不是bottom，如果第一次插入，则可以插入
                                if beili_count_today_bottom == 0 and beili_count_today_top == 0 and beili_count_yestoday_top == 0:
                                    if latest_rec and latest_rec[0]['type'] != 'bottom':
                                        self.logger.critical(f"latest_rec:{latest_rec}")
                                        self.beili.insert(
                                            {'code': k, 'type': 'bottom', 'price': curr_price, 'trade_state': 'trading',
                                             'trade_days': 0, 'date': self.today, 'time': str(curr_time.time())})
                                        self.logger.info(f"latest_rec:{latest_rec}")
                                        self.logger.info(
                                            f"insert_bottom: code:{k}, 'date':{self.today},'curr_time:'{curr_time.time()}, 'type':bottom, 'curr_price':{curr_price}, 'yes2_close':{self.yes2_close}, 'yes1_close':{self.yes1_close}, 'ma10':{self.ma10}, 'ma8':{self.yes1_ma8}, 'ma7':{self.yes1_ma7}, 'ma6':{self.yes1_ma6} ")
                                    elif not latest_rec:
                                        self.beili.insert(
                                            {'code': k, 'type': 'bottom', 'price': curr_price, 'trade_state': 'trading',
                                             'trade_days': 0, 'date': self.today, 'time': str(curr_time)})
                                        self.logger.info(
                                            f"insert_bottom: code:{k}, 'date':{self.today},'curr_time:'{curr_time.time()}, 'type':bottom, 'curr_price':{curr_price}, 'yes2_close':{self.yes2_close}, 'yes1_close':{self.yes1_close}, 'ma10':{self.ma10}, 'ma8':{self.yes1_ma8}, 'ma7':{self.yes1_ma7}, 'ma6':{self.yes1_ma6} ")

                            # 判断是否上涨
                            if (self.yes2_close <= self.yes1_close and self.yes2_lowest <= self.yes1_lowest and self.yes2_highest <= self.yes1_highest) and \
                                    self.yes1_ma8 < curr_price and (self.yes1_ma4 > self.yes2_ma4 and self.yes1_ma5 > self.yes2_ma5 and self.yes1_ma6 > self.yes2_ma6 and self.yes1_ma7 > self.yes2_ma7  and self.yes1_ma8 > self.yes2_ma8):
                                beili_count = self.beili.count_documents({'code': k, 'date': self.today, 'type': 'bottom'})

                                beili_count_today_bottom = self.beili.count_documents({'code': k, 'date': self.today, 'type': 'bottom'})
                                beili_count_today_top = self.beili.count_documents({'code': k, 'date': self.today, 'type': 'top'})
                                beili_count_yestoday_top = self.beili.count_documents({'code': k, 'date': self.yestoday, 'type': 'top'})
                                # 当天没有插入过，且最近一次的插入不是bottom，如果第一次插入，则可以插入
                                if beili_count_today_bottom == 0 and beili_count_today_top == 0 and beili_count_yestoday_top == 0:
                                    if latest_rec and latest_rec[0]['type'] != 'bottom':
                                        self.logger.critical(f"latest_rec:{latest_rec}")
                                        self.beili.insert({'code': k, 'type': 'bottom', 'price': curr_price, 'trade_state': 'trading', 'trade_days': 0, 'date': self.today, 'time': str(curr_time.time())})
                                        self.logger.info(f"latest_rec:{latest_rec}")
                                        self.logger.info(f"insert_bottom: code:{k}, 'date':{self.today},'curr_time:'{curr_time.time()}, 'type':bottom, 'curr_price':{curr_price}, 'yes2_close':{self.yes2_close}, 'yes1_close':{self.yes1_close}, 'ma10':{self.ma10}, 'ma8':{self.yes1_ma8}, 'ma7':{self.yes1_ma7}, 'ma6':{self.yes1_ma6} ")
                                    elif not latest_rec:
                                        self.beili.insert({'code': k, 'type': 'bottom', 'price': curr_price, 'trade_state': 'trading', 'trade_days': 0, 'date': self.today, 'time': str(curr_time)})
                                        self.logger.info(f"insert_bottom: code:{k}, 'date':{self.today},'curr_time:'{curr_time.time()}, 'type':bottom, 'curr_price':{curr_price}, 'yes2_close':{self.yes2_close}, 'yes1_close':{self.yes1_close}, 'ma10':{self.ma10}, 'ma8':{self.yes1_ma8}, 'ma7':{self.yes1_ma7}, 'ma6':{self.yes1_ma6} ")

                            # 如果还没出现底部，跳过
                            if not latest_rec:
                                self.logger.info(f"{curr_time} continue1:{k}")
                                continue

                            # 如果最近一条记录是top，或者当天出现过top，那么跳过买动作
                            if (latest_rec and latest_rec[0]['type'] == 'top') or self.isAppear_top:
                                self.logger.info(f"{curr_time} continue2:{k}")
                                continue

                            # 如果你是底部，但是现在价格低于了这个底部，那就不能买，应该全卖出
                            if latest_rec and latest_rec[0]['type'] == 'bottom' and latest_rec[0]['price'] > curr_price:
                                self.logger.info(f"{curr_time} continue3:{k}")
                                continue

                            # 入场资金控制
                            # ------------------------------------------------------------------------------------------


                            # 设定所有股票的总仓位
                            all_buy = self.trade_rec.find({'isSold': 0})
                            today_all_buy = self.hasBuy.find({'buy_date': self.today})
                            all_buy_money = 0
                            for a in all_buy:
                                all_buy_money += a['left_num'] * a['cost']
                            for r in today_all_buy:
                                all_buy_money += r['money']

                            if all_buy_money >= self.trands_top_money:
                                self.logger.info(f"{curr_time} continue4:{k}")
                                continue


                            # 如果出现顶背离现象，且还不是特别严重，减少入场资金
                            cond1 = not (self.yes2_lowest < self.yes1_lowest and self.yes2_highest < self.yes1_highest)
                            cond2 = (self.yes1_ma7 > self.yes2_ma7 or self.yes1_ma6 > self.yes2_ma6 or self.yes1_ma8 > self.yes2_ma8)
                            cond3 = (self.yes1_ma4 > curr_price or self.yes1_ma5 > curr_price or self.yes1_ma6 > curr_price or self.yes1_ma7 > curr_price)
                            if (cond1 and cond2 and cond3):
                                self.logger.info(f"{curr_time} continue5:{k}")
                                continue
                            # ------------------------------------------------------------------------------------------

                            latest_rec = self.beili.find({'code': k}).sort('_id', -1).limit(1)
                            latest_rec = [x for x in latest_rec]
                            if latest_rec and latest_rec[0]['type'] == 'bottom':

                                # 根据left_money 来确定self.money12
                                # left_money = per_top_money

                                # if left_money > 0:
                                if self.yes1_macd >= 0.011 and (self.yes2_lowest < self.yes1_lowest and self.yes2_highest < self.yes1_highest):
                                    self.money1 = self.per_top_money
                                    # self.money2 = self.money1
                                    # self.money3 = self.money2 + self.money1
                                    # self.money4 = 0
                                    # self.money5 = 0

                                    bt1_nums = self.hasBuy.count_documents({'bt': 1,'buy_date':self.today})
                                    bt2_nums = self.hasBuy.count_documents({'bt': 2,'buy_date':self.today})
                                    bt3_nums = self.hasBuy.count_documents({'bt': 3,'buy_date':self.today})
                                    bt4_nums = self.hasBuy.count_documents({'bt': 4,'buy_date':self.today})
                                    bt5_nums = self.hasBuy.count_documents({'bt': 5,'buy_date':self.today})
                                    bt2_lst = self.hasBuy.find({'bt': 2,'buy_date':self.today})
                                    bt3_lst = self.hasBuy.find({'bt': 3,'buy_date':self.today})
                                    bt4_lst = self.hasBuy.find({'bt': 4,'buy_date':self.today})
                                    bt2_codes = []
                                    bt3_codes = []
                                    bt4_codes = []
                                    for b in bt3_lst:
                                        bt3_codes.append(b['code'])
                                    for c in bt4_lst:
                                        bt4_codes.append(c['code'])

                                    # if bt1_nums > 8 and (k not in bt1_codes):
                                    #     continue
                                    if bt3_nums > 4 and (k not in bt3_codes):
                                        self.logger.info(f"{curr_time} continue5:{k}")
                                        continue
                                    if bt4_nums > 2 and (k not in bt4_codes):
                                        self.logger.info(f"{curr_time} continue6:{k}")
                                        continue

                                    # isOnlyOne = self.hasBuy.find_one({'bt': 1,'buy_date':self.today})
                                    # print('isOnlyOne', isOnlyOne)
                                    # if isOnlyOne and isOnlyOne['code'] != k:
                                    #     continue
                                else:
                                    self.logger.info(f"{curr_time} continue7:{k}")
                                    continue
                            else:
                                self.logger.info(f"{curr_time} continue8:{k}")
                                continue

                            buy_cond1 = (len(self.catch_lowest[k]) > 1)
                            buy_cond2 = (self.catch_lowest[k].iloc[0] == today_lowest)
                            buy_cond3 = (self.catch_lowest[k].max() == self.catch_lowest[k].iloc[-1])
                            buy_cond4 = (self.catch_lowest[k].iloc[-1] - today_lowest >= 0.003)

                            # 如果当前记录长度大于1，且最新进场价格大于第一个价格(最低价格)，那么买入？
                            if buy_cond1 and buy_cond2 and buy_cond3:
                                # if 1:
                                # print(k, '进入买监控一阶段：', '差值:', (self.catch_lowest[k].iloc[-1] - today_lowest) / today_lowest,
                                #       ':开头:',
                                #       self.catch_lowest[k].iloc[0], ':结尾:', self.catch_lowest[k].iloc[-1], ':现价:',
                                #       curr_price, ':阶段最大：',
                                #       self.catch_lowest[k].max(), ':当日最低:', today_lowest, ':当前长度:',
                                #       len(self.catch_lowest[k]))
                                # 根据标的价位设定入场目标
                                act = ''

                                if buy_cond4 and ((curr_time.hour == 9 and curr_time.minute >= 31) or curr_time.hour >= 10):
                                    # if 1:
                                    act = 'buy'

                                # 查询时间
                                hasBuy = self.hasBuy.count_documents({'code': k, 'buy_date': self.today})
                                ndict = {}
                                ndict['code'] = k
                                ndict['price'] = curr_price
                                luocha = 0.003

                                if hasBuy == 0 and act == 'buy' and ((curr_time.hour == 9 and curr_time.minute >= 31) or curr_time.hour >= 10):
                                    if bt1_nums <= 3:
                                        money = self.money1 * 2
                                        next_bt = 1
                                    elif bt1_nums <= 7:
                                        money = self.money1
                                        next_bt = 2
                                    elif bt1_nums <= 10:
                                        money = self.money1 * 0.5
                                        next_bt = 3
                                    else:
                                        money = self.money1 * 0.25
                                        next_bt = 3
                                    if money + all_buy_money > self.trands_top_money and all_buy_money < self.trands_top_money:
                                        money = self.trands_top_money - all_buy_money

                                    money = self.money1

                                    buyMoney = (round(money / ndict['price'] / 100) * 100) * curr_price
                                    ndict['bt'] = 1
                                    if money == 0:
                                        cost = 0
                                        num = 0
                                    else:
                                        # 计算成本单价
                                        cost = (buyMoney * (1 + 0.0005)) / (round(money / ndict['price'] / 100) * 100)
                                        num = (round(money / ndict['price'] / 100) * 100)
                                    self.hasBuy.insert_one(
                                        {'code': k, 'price': curr_price, 'time': str(curr_time), 'buy_date': self.today,
                                         'bt': 1, 'next_bt':0, 'money': buyMoney,
                                         'isSold': 0, 'cost': cost, 'num': num, 'pct_bt': 0, 'yingkui': 0})

                                    self.logger.info(
                                        'buy_point: ' + str(k) + '   ' + str(curr_price) + '   ' + str(
                                            money) + '   ' + str(curr_time))

                                    self.catch_lowest[k] = pd.Series()


                                elif hasBuy == 1 and act == 'buy':

                                    # 判断间隔时间
                                    res = self.hasBuy.find_one({'code': ndict['code'], 'buy_date': self.today, 'bt': 1})
                                    t1 = datetime.datetime.strptime(res['time'][0:19], '%Y-%m-%d %H:%M:%S')

                                    if (curr_time - t1).total_seconds() > 480 and curr_price <= res['price'] - luocha:
                                        # if self.money2 < res['money']:
                                        #     money = res['money'] * 2
                                        # else:
                                        n_bt = int((res['price'] - curr_price)/0.003)
                                        money = res['money'] * n_bt
                                        if money >= self.per_top_money * 10:
                                            money = res['money']

                                        if money + all_buy_money > self.trands_top_money and all_buy_money < self.trands_top_money:
                                            money = self.trands_top_money - all_buy_money

                                        buyMoney = (round(money / ndict['price'] / 100) * 100) * curr_price
                                        ndict['bt'] = 2
                                        if money == 0:
                                            cost = 0
                                            num = 0
                                        else:
                                            # 计算成本单价
                                            cost = (buyMoney * (1 + 0.0005)) / (
                                                        round(money / ndict['price'] / 100) * 100)
                                            num = (round(money / ndict['price'] / 100) * 100)

                                        self.hasBuy.insert_one(
                                            {'code': k, 'price': curr_price, 'time': str(curr_time),
                                             'buy_date': self.today, 'bt': ndict['bt'], 'next_bt':n_bt,
                                             'money': buyMoney, 'isSold': 0, 'cost': cost, 'num': num, 'pct_bt': 0,
                                             'yingkui': 0})

                                        self.logger.info(
                                            'buy_point: ' + str(k) + '   ' + str(curr_price) + '   ' + str(
                                                money) + '   ' + str(curr_time))

                                        # self.autoBuy(ndict, money, 'sale1')
                                        print('低点2次', k)

                                        self.catch_lowest[k] = pd.Series()

                                elif hasBuy == 2 and act == 'buy':

                                    # 判断间隔时间
                                    res = self.hasBuy.find_one({'code': ndict['code'], 'buy_date': self.today, 'bt': 2})
                                    t1 = datetime.datetime.strptime(res['time'][0:19], '%Y-%m-%d %H:%M:%S')

                                    if (curr_time - t1).total_seconds() > 480 and curr_price <= res['price'] - luocha:
                                        # if self.money3 < res['money']:
                                        #     money = res['money']
                                        # else:
                                        n_bt = int((res['price'] - curr_price)/0.003)
                                        money = res['money'] * n_bt
                                        if money >= self.per_top_money * 10:
                                            money = res['money']

                                        if money + all_buy_money > self.trands_top_money and all_buy_money < self.trands_top_money:
                                            money = self.trands_top_money - all_buy_money

                                        buyMoney = (round(money / ndict['price'] / 100) * 100) * curr_price
                                        ndict['bt'] = 3
                                        if money == 0:
                                            cost = 0
                                            num = 0
                                        else:
                                            # 计算成本单价
                                            cost = (buyMoney * (1 + 0.0005)) / (
                                                        round(money / ndict['price'] / 100) * 100)
                                            num = (round(money / ndict['price'] / 100) * 100)
                                        self.hasBuy.insert_one(
                                            {'code': k, 'price': curr_price, 'time': str(curr_time),
                                             'buy_date': self.today, 'bt': ndict['bt'], 'next_bt':n_bt,
                                             'money': buyMoney, 'isSold': 0, 'cost': cost, 'num': num, 'pct_bt': 0,
                                             'yingkui': 0})

                                        self.logger.info(
                                            'buy_point: ' + str(k) + '   ' + str(curr_price) + '   ' + str(
                                                money) + '   ' + str(curr_time))

                                        # self.autoBuy(ndict, money, 'sale1')
                                        print('低点3次，买入成功', k)

                                        self.catch_lowest[k] = pd.Series()

                                elif hasBuy == 3 and act == 'buy':

                                    # 判断间隔时间
                                    res = self.hasBuy.find_one({'code': ndict['code'], 'buy_date': self.today, 'bt': 3})
                                    t1 = datetime.datetime.strptime(res['time'][0:19], '%Y-%m-%d %H:%M:%S')

                                    if (curr_time - t1).total_seconds() > 480 and curr_price <= res['price'] - luocha:
                                        # if self.money4 < res['money']:
                                        #     money = res['money']
                                        # else:
                                        money = 0

                                        if money + all_buy_money > self.trands_top_money and all_buy_money < self.trands_top_money:
                                            money = self.trands_top_money - all_buy_money

                                        buyMoney = (round(money / ndict['price'] / 100) * 100) * curr_price
                                        ndict['bt'] = 4
                                        if money == 0:
                                            cost = 0
                                            num = 0
                                        else:
                                            # 计算成本单价
                                            cost = (buyMoney * (1 + 0.0005)) / (
                                                        round(money / ndict['price'] / 100) * 100)
                                            num = (round(money / ndict['price'] / 100) * 100)
                                        self.hasBuy.insert_one(
                                            {'code': k, 'price': curr_price, 'time': str(curr_time),
                                             'buy_date': self.today, 'bt': ndict['bt'],
                                             'money': buyMoney, 'isSold': 0, 'cost': cost, 'num': num, 'pct_bt': 0,
                                             'yingkui': 0})

                                        self.logger.info(
                                            'buy_point: ' + str(k) + '   ' + str(curr_price) + '   ' + str(
                                                money) + '   ' + str(curr_time))

                                        # self.autoBuy(ndict, money, 'sale1')
                                        print('低点4次，买入成功', k)

                                        self.catch_lowest[k] = pd.Series()

                                elif hasBuy == 4 and act == 'buy':

                                    # 判断间隔时间
                                    res = self.hasBuy.find_one({'code': ndict['code'], 'buy_date': self.today, 'bt': 4})
                                    t1 = datetime.datetime.strptime(res['time'][0:19], '%Y-%m-%d %H:%M:%S')

                                    if (curr_time - t1).total_seconds() > 480 and curr_price <= res['price'] - luocha:
                                        # if self.money5 < res['money']:
                                        #     money = res['money']
                                        # else:
                                        money = 0

                                        if money + all_buy_money > self.trands_top_money and all_buy_money < self.trands_top_money:
                                            money = self.trands_top_money - all_buy_money

                                        buyMoney = (round(money / ndict['price'] / 100) * 100) * curr_price
                                        ndict['bt'] = 5
                                        if money == 0:
                                            cost = 0
                                            num = 0
                                        else:
                                            # 计算成本单价
                                            cost = (buyMoney * (1 + 0.0005)) / (
                                                        round(money / ndict['price'] / 100) * 100)
                                            num = (round(money / ndict['price'] / 100) * 100)
                                        self.hasBuy.insert_one(
                                            {'code': k, 'price': curr_price, 'time': str(curr_time),
                                             'buy_date': self.today, 'bt': ndict['bt'],
                                             'money': buyMoney, 'isSold': 0, 'cost': cost, 'num': num, 'pct_bt': 0,
                                             'yingkui': 0})

                                        self.logger.info(
                                            'buy_point: ' + str(k) + '   ' + str(curr_price) + '   ' + str(
                                                money) + '   ' + str(curr_time))

                                        # self.autoBuy(ndict, money, 'sale1')
                                        print('低点5次，买入成功', k)

                                        self.catch_lowest[k] = pd.Series()
                    except Exception as e:
                        # raise e
                        print(e)


    def jk_sale(self, curr_time, ser, lastreq):
        log_msg = ' Sale: ' + ' curr_time:' + str(curr_time)
        if (curr_time.hour == 9 and curr_time.minute >= 30) or curr_time.hour >= 10:
            # if 1:
            try:
                # 获取市场行情，进行交易评级quotation
                # pct_sh, pct_sz = self.dp()
                # qttA = 0.65
                # qttB = 0.5
                # qttC = 0.35
                # qttD = 0.2

                # 查询已买,且有仓位可以卖
                res = self.trade_rec.find({'isSold': 0})

                # 因为一个code,未卖出单子可能很多，如果其中一个满足条件卖出就清空self.catch_highest是不合理的，所以需要等这个code的遍历完了，只要有卖出就清空
                clean_flag = False

                for r in res:

                    if r['code'] != lastreq['code']:
                        continue
                    if r['money'] == 0:
                        continue

                    # 没有被卖，那么获取当前分时价格，然后和bt价格对比
                    today_highest = lastreq['today_highest']
                    curr_price = lastreq['curr_price']

                    # 抓捕当日最高价格
                    curr_time_temp = str(curr_time)
                    if self.highest_price[r['code']] < today_highest:
                        self.highest_price[r['code']] = today_highest
                        self.catch_highest[r['code']] = pd.Series()
                        self.catch_highest[r['code']][curr_time] = today_highest
                    else:
                        self.catch_highest[r['code']][curr_time_temp] = ser[r['code']]

                    if not curr_price or not today_highest:
                        continue

                    # 更新当前盈利情况
                    # new_yingkui = r['left_num'] * (curr_price - r['cost']) + r['yingkui1'] + r['yingkui2'] + r[
                    #     'yingkui3']
                    # pct_bt = round(new_yingkui / r['money'], 2)
                    # if not new_yingkui:
                    #     new_yingkui = 0
                    # if not pct_bt:
                    #     pct_bt = 0
                    #
                    # self.trade_rec.update_one({'code': r['code'], '_id': r['_id']},
                    #                           {'$set': {'pct_bt': pct_bt, 'yingkui': new_yingkui}})

                    # 更新当前距离成本价之后的最高价格
                    if curr_price > r['highest_price']:
                        self.trade_rec.update_one({'code': r['code'], '_id': r['_id']},{'$set': {'highest_price':curr_price, 'highest_time':str(curr_time)}})

                    self.trade_rec.update_one({'code': r['code'], '_id': r['_id']},{'$set': {'curr_price':curr_price}})

                    if curr_price == 0:
                        continue

                    dict = {}
                    dict['code'] = r['code']

                    # ----------------------------------------------------------
                    # 卖出逻辑：如果价格回撤0.003个点，与昨日买入或者今日买入价格对比。
                    # 不管现价是否低于昨日最低买入价格，那么都要记录当前价格，因为当在今日买入时，需要比较现价与当日买入价格，但是如果现价低于了当日买入价格，那就没有再记录的必要。
                    # if ser[r['code']] == today_highest:
                    #     self.catch_highest[r['code']] = pd.Series()

                    # 把分时时时价格存入
                    # curr_time_temp = str(curr_time)
                    # self.catch_highest[r['code']][curr_time_temp] = ser[r['code']]


                    # latest_rec = self.beili.find({'code': r['code']}).sort('_id', -1).limit(1)
                    # latest_rec = [x for x in latest_rec]
                    # if latest_rec and latest_rec[0]['type'] == 'bottom':
                    #     if self.yes1_macd <= 0.011:
                    #         zhiying_del = int(latest_rec[0]['trade_days']) * 0.004
                    #     elif self.yes1_macd > 0.011:
                    #         zhiying_del = int(latest_rec[0]['trade_days']) * 0.002
                    # else:
                    #     zhiying_del = 0


                    # todayCang = self.trade_rec.find({'code': r['code'], 'isSold': 0})
                    # cangWei = 0
                    # for t in todayCang:
                    #      cangWei += (t['left_num'] * t['cost'])
                    # sold_type = ''
                    # if cangWei > self.top_cangwei4:
                    #     zhiying = 0.006
                    #     sold_type = 'cangWei > self.top_cangwei4'
                    # elif cangWei > self.top_cangwei3:
                    #     zhiying = 0.01
                    #     sold_type = 'cangWei > self.top_cangwei3'
                    # else:
                    #     zhiying = 0.016
                    #     sold_type = 'zhiying0.016'
                    # elif cangWei > self.top_cangwei2:
                    #     zhiying = 0.018 - zhiying_del
                    #     sold_type = 'cangWei > self.top_cangwei2'
                    # elif cangWei > self.top_cangwei1:
                    #     zhiying = 0.022 - zhiying_del
                    #     sold_type = 'cangWei > self.top_cangwei1'
                    # else:
                    #     zhiying = 0.026 - zhiying_del
                    #     sold_type = 'yingli0.068'
                    #
                    # if zhiying < 0.004:
                    #     zhiying = 0.004

                    # 如果出现顶背离现象，且还不是特别严重，降低止盈位置
                    # cond1 = (self.yes2_close >= self.yes1_close or self.yes2_lowest >= self.yes1_lowest or self.yes2_highest >= self.yes1_highest)
                    # cond2 = (self.yes1_ma7 > self.yes2_ma7 or self.yes1_ma6 > self.yes2_ma6 or self.yes1_ma8 > self.yes2_ma8)
                    # cond3 = (self.yes1_ma4 > curr_price or self.yes1_ma5 > curr_price or self.yes1_ma6 > curr_price or self.yes1_ma7 > curr_price)
                    # if cond1 and cond2 and cond3:
                    #
                    #     if cangWei > self.top_cangwei4:
                    #         zhiying = -0.01
                    #         sold_type = 'cangWei > self.top_cangwei4, beili'
                    #     elif cangWei > self.top_cangwei3:
                    #         zhiying = 0
                    #         sold_type = 'cangWei > self.top_cangwei3, beili'
                    #     elif cangWei > self.top_cangwei2:
                    #         zhiying = 0.004
                    #         sold_type = 'cangWei > self.top_cangwei2, beili'
                    #     elif cangWei > self.top_cangwei1:
                    #         zhiying = 0.009
                    #         sold_type = 'cangWei > self.top_cangwei1, beili'
                    #     else:
                    #         zhiying = 0.012
                    #         sold_type = '轻微 top beili'

                    # if self.yes1_macd >= -0.011 and self.yes1_macd <= 0.011 and latest_rec[0]['type'] == 'bottom' and  latest_rec[0]['trade_days'] > 4:
                    #     zhiying = 0.012
                    #     sold_type = 'macd'

                    # 当大于昨日成本价之后，才开始监控回落
                    zhiying = 0.004
                    sold_type = 'zhiying0.004'
                    sale_cond1 = (r['highest_price'] - r['cost'])/r['cost'] > zhiying
                    # sale_cond2 = (len(self.catch_highest[r['code']]) > 1)
                    # sale_cond3 = (today_highest >= self.catch_highest[r['code']].iloc[0])
                    # sale_cond4 = (self.catch_highest[r['code']].iloc[0] >= (today_highest - 0.0015))
                    # sale_cond5 = (self.catch_highest[r['code']].min() == self.catch_highest[r['code']].iloc[-1])

                    # # 如果是顶背离，或者出现假底部，那么卖出
                    # is_top_beili = (self.yes2_close >= self.yes1_close or self.yes2_lowest >= self.yes1_lowest or self.yes2_highest >= self.yes1_highest) and self.yes1_ma8 > curr_price and (
                    #                        self.yes1_ma7 > self.yes2_ma7 or self.yes1_ma6 > self.yes2_ma6 or self.yes1_ma8 > self.yes2_ma8)
                    # is_false_bottom = (latest_rec and latest_rec[0]['type'] == 'bottom' and latest_rec[0]['price'] * 0.99 > curr_price)
                    #
                    # if is_top_beili:
                    #     sale_cond1 = True
                    #     sold_type = 'top_beili'
                    # if is_false_bottom:
                    #     sale_cond1 = True
                    #     sold_type = 'false_bottom'

                    # # 如果昨日仓位大于4次购买，约大于6000 , 那么在当日最高点卖出，不再积累仓位
                    # try:
                    #     yes_buy = self.trade_rec.find_one({'code': r['code'], 'isSold': 0, 'buy_date': self.yestoday})
                        # self.logger.debug(f"{yes_buy}")
                        # if yes_buy and 'money' in yes_buy:
                        #     yes_cang = yes_buy['money']
                        #     if yes_cang >= 36000:
                        #         sale_cond1 = ((curr_price - r['cost']) / r['cost'] >= 0.004)
                        #         sold_type = 'yes_cang >= self.top_cangwei1'
                        #         # self.logger.debug(f"sale_cond1:{sale_cond1}")

                        # if yes_buy and 'bts' in yes_buy:
                        #     # yes_cang = yes_buy['money']
                        #     if yes_buy['bts'] >= 4:
                        #         sale_cond1 = True
                        #         sold_type = "yes_buy['bts'] >= 4"

                    # except Exception as e:
                    #     self.logger.error(e)

                    # 获取最近插入的数据
                    latest_rec = self.beili.find({'code': r['code']}).sort('_id', -1).limit(1)
                    latest_rec = [x for x in latest_rec]
                    is_top_beili = (latest_rec and latest_rec[0]['type'] == 'top' and latest_rec[0]['date'] == self.yestoday)


                    # if ((curr_price <= self.yes1_lowest or self.yes1_macd <= 0.01) and (not (self.yes1_highest > self.yes2_highest and self.yes1_lowest > self.yes2_lowest))):
                    #     sale_cond1 = True
                    #     sold_type = "macd<=0.01_xiadiequshi"
                    if is_top_beili:
                        sale_cond1 = True
                        sold_type = "top_beili"

                    # if sale_cond1 and sale_cond2 and sale_cond3 and sale_cond4 and sale_cond5:
                    if sale_cond1:

                        # self.logger.debug(f'today:{self.today},time:{curr_time},highest:{today_highest}')
                        # sold_type = 'yingli>0.008'
                        # 判断回落点,设置止盈
                        act = ''
                        # 判断回落点数是否大于0.003
                        # if self.catch_highest[r['code']].max() - self.catch_highest[r['code']][-1] >= 0.003:
                            # self.logger.debug(f"self.catch_highest[r['code']].max() - self.catch_highest[r['code']][-1] >= 0.003:{self.catch_highest[r['code']].max() - self.catch_highest[r['code']][-1] >= 0.003}")
                            # 如果macd在-0.01-0.01范围，且trade大于了2，那么一次卖出，减少仓位，否则分三次卖出

                        if (sold_type == "macd<=0.01_xiadiequshi" or sold_type == "top_beili") and (curr_time.hour == 14 and curr_time.minute >= 58):
                            if r['st'] != 0:
                                dict['num'] = r['left_num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                curr_yingkui = dict['num'] * (curr_price - r['cost'])
                                yingkui = dict['num'] * (curr_price - r['cost']) + r['yingkui']
                                # sold_type = 'yingli_top_beili'
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': 1, 'left_num': 0,
                                             'st':r['st']+1,
                                             f"soldTime{r['st']+1}": str(curr_time),
                                             f"soldPrice{r['st']+1}": curr_price,
                                             f"sold_type{r['st']+1}": sold_type,
                                             f"yingkui{r['st']+1}": curr_yingkui,
                                             'yingkui': yingkui}})
                            else:
                                dict['num'] = r['left_num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                yingkui = dict['num'] * (curr_price - r['cost'])
                                # sold_type = 'yingli_top_beili'
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': 1, 'left_num': 0, 'st':1, 'soldTime1': str(curr_time),
                                             'soldPrice1': curr_price, 'sold_type1': sold_type,
                                             'yingkui1': yingkui, 'yingkui': yingkui}})

                                self.logger.info(
                                    'sale_point: ' + str(r['code']) + '   ' + str(yingkui) + '   ' + str(curr_time))
                            # 如果有进来过那么，clean_flag 标记为清空
                            clean_flag = True
                        elif (sold_type == "macd<=0.01_xiadiequshi" or sold_type == "top_beili") and (today_highest - curr_price)/today_highest >= 0.003:
                            sold_type += '_趋势止损'
                            if r['st'] == 0:
                                if r['left_num'] < 300:
                                    dict['num'] = r['left_num']
                                    isSold = 1
                                else:
                                    dict['num'] = int(r['left_num'] / 300) * 100
                                    isSold = 0
                                left_num = r['left_num'] - dict['num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                yingkui1 = dict['num'] * (curr_price - r['cost'])
                                yingkui = yingkui1
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': isSold, 'st': 1, 'left_num': left_num, 'left_num1': left_num,
                                             'soldNum1': dict['num'], 'soldTime1': str(curr_time),
                                             'soldPrice1': curr_price,
                                             'yingkui': yingkui, 'yingkui1': yingkui1, 'sold_type1': sold_type}})

                                self.logger.debug(f"st1 ,soldNum1:{dict['num']},soldTime1:{str(curr_time)},soldPrice1:{curr_price},yingkui:{yingkui}")
                            elif r['st'] == 1 and (curr_price - 0.003 >= r['soldPrice1']):
                                if r['left_num'] < 300:
                                    dict['num'] = r['left_num']
                                    isSold = 1
                                else:
                                    dict['num'] = int(r['left_num'] / 200) * 100
                                    isSold = 0
                                left_num = r['left_num'] - dict['num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                yingkui2 = dict['num'] * (curr_price - r['cost'])
                                yingkui = r['yingkui1'] + yingkui2
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': isSold, 'st': 2, 'left_num': left_num, 'left_num2': left_num,
                                             'soldNum2': dict['num'], 'soldTime2': str(curr_time),
                                             'soldPrice2': curr_price,
                                             'yingkui': yingkui, 'yingkui2': yingkui2, 'sold_type2': sold_type}})
                            elif r['st'] == 2 and (curr_price - 0.003 >= r['soldPrice2']):
                                dict['num'] = r['left_num']
                                left_num = r['left_num'] - dict['num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                yingkui3 = dict['num'] * (curr_price - r['cost'])
                                yingkui = r['yingkui1'] + r['yingkui2'] + yingkui3
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': 1, 'st': 3, 'left_num': left_num, 'left_num3': left_num,
                                             'soldNum3': dict['num'], 'soldTime3': str(curr_time),
                                             'soldPrice3': curr_price,
                                             'yingkui': yingkui, 'yingkui3': yingkui3, 'sold_type3': sold_type}})

                                self.logger.debug(
                                    f"st1 ,soldNum3:{dict['num']},soldTime3:{str(curr_time)},soldPrice3:{curr_price},yingku3:{yingkui}")
                            # 如果有进来过那么，clean_flag 标记为清空
                            clean_flag = True
                        elif (r['highest_price'] - curr_price)/r['highest_price'] > 0.008 and curr_price > r['cost']:
                            sold_type += '_止盈0.008'
                            if r['st'] != 0:
                                dict['num'] = r['left_num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                curr_yingkui = dict['num'] * (curr_price - r['cost'])
                                yingkui = dict['num'] * (curr_price - r['cost']) + r['yingkui']
                                # sold_type = 'yingli_top_beili'
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': 1, 'left_num': 0,
                                             'st':r['st']+1,
                                             f"soldTime{r['st']+1}": str(curr_time),
                                             f"soldPrice{r['st']+1}": curr_price,
                                             f"sold_type{r['st']+1}": sold_type,
                                             f"yingkui{r['st']+1}": curr_yingkui,
                                             'yingkui': yingkui}})
                            else:
                                dict['num'] = r['left_num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                yingkui = dict['num'] * (curr_price - r['cost'])
                                # sold_type = 'yingli_top_beili'
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': 1, 'left_num': 0, 'st':1, 'soldTime1': str(curr_time),
                                             'soldPrice1': curr_price, 'sold_type1': sold_type,
                                             'yingkui1': yingkui, 'yingkui': yingkui}})

                                self.logger.info(
                                    'sale_point: ' + str(r['code']) + '   ' + str(yingkui) + '   ' + str(curr_time))
                            # 如果有进来过那么，clean_flag 标记为清空
                            clean_flag = True

                        elif (r['highest_price'] - curr_price)/r['highest_price'] > 0.004 and curr_price > r['cost']:
                            sold_type += '_止盈0.004'
                            if r['st'] == 0:
                                if r['left_num'] < 300:
                                    dict['num'] = r['left_num']
                                    isSold = 1
                                else:
                                    dict['num'] = int(r['left_num'] / 300) * 100
                                    isSold = 0
                                left_num = r['left_num'] - dict['num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                yingkui1 = dict['num'] * (curr_price - r['cost'])
                                yingkui = yingkui1
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': isSold, 'st': 1, 'left_num': left_num, 'left_num1': left_num,
                                             'soldNum1': dict['num'], 'soldTime1': str(curr_time),
                                             'soldPrice1': curr_price,
                                             'yingkui': yingkui, 'yingkui1': yingkui1, 'sold_type1': sold_type}})

                                self.logger.debug(f"st1 ,soldNum1:{dict['num']},soldTime1:{str(curr_time)},soldPrice1:{curr_price},yingkui:{yingkui}")
                            elif r['st'] == 1 and (curr_price - 0.003 >= r['soldPrice1']):
                                if r['left_num'] < 300:
                                    dict['num'] = r['left_num']
                                    isSold = 1
                                else:
                                    dict['num'] = int(r['left_num'] / 200) * 100
                                    isSold = 0
                                left_num = r['left_num'] - dict['num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                yingkui2 = dict['num'] * (curr_price - r['cost'])
                                yingkui = r['yingkui1'] + yingkui2
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': isSold, 'st': 2, 'left_num': left_num, 'left_num2': left_num,
                                             'soldNum2': dict['num'], 'soldTime2': str(curr_time),
                                             'soldPrice2': curr_price,
                                             'yingkui': yingkui, 'yingkui2': yingkui2, 'sold_type2': sold_type}})
                            elif r['st'] == 2 and (curr_price - 0.003 >= r['soldPrice2']):
                                dict['num'] = r['left_num']
                                left_num = r['left_num'] - dict['num']
                                condition = {'code': r['code'], '_id': r['_id']}
                                yingkui3 = dict['num'] * (curr_price - r['cost'])
                                yingkui = r['yingkui1'] + r['yingkui2'] + yingkui3
                                self.trade_rec.update_one(condition, {
                                    '$set': {'isSold': 1, 'st': 3, 'left_num': left_num, 'left_num3': left_num,
                                             'soldNum3': dict['num'], 'soldTime3': str(curr_time),
                                             'soldPrice3': curr_price,
                                             'yingkui': yingkui, 'yingkui3': yingkui3, 'sold_type3': sold_type}})

                                self.logger.debug(
                                    f"st1 ,soldNum3:{dict['num']},soldTime3:{str(curr_time)},soldPrice3:{curr_price},yingku3:{yingkui}")
                            # 如果有进来过那么，clean_flag 标记为清空
                            clean_flag = True

                    # 获取最近插入的数据
                    # latest_rec = self.beili.find({'code': r['code']}).sort('_id', -1).limit(1)
                    # latest_rec = [x for x in latest_rec]
                    # 如果最近一次插入为top，检查仓位，不能持仓, 避免前一天出现bottom后有买入，但是前一天后面又删除bottom，那么买入就不成立，应该在次日卖出
                    # 或者前一天bottom买入后出现了top顶背离情况
                    # 只要出现背离，那么则卖出???
                    # if self.yes1_macd <= 0.008 and (not (self.yes1_highest > self.yes2_highest and self.yes1_lowest > self.yes2_lowest)):
                    #     if r['st'] != 0:
                    #         dict['num'] = r['left_num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost']) + r['yingkui']
                    #         sold_type = 'top_beili_xiadie_qushi'
                    #         self.trade_rec.update_one(condition, {
                    #             '$set': {'isSold': 1, 'left_num': 0, 'soldTime': str(curr_time),
                    #                      'soldPrice': curr_price, 'sold_type': sold_type,
                    #                      'yingkui': yingkui}})
                    #     else:
                    #         dict['num'] = r['num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost'])
                    #         sold_type = 'top_beili_xiadie_qushi'
                    #         self.trade_rec.update_one(condition, {
                    #             '$set': {'isSold': 1, 'left_num': 0, 'soldTime': str(curr_time),
                    #                      'soldPrice': curr_price, 'sold_type': sold_type,
                    #                      'yingkui': yingkui}})
                    #
                    #         self.logger.info(
                    #             'sale_point: ' + str(r['code']) + '   ' + str(yingkui) + '   ' + str(curr_time))
                    #         # 如果有进来过那么，clean_flag 标记为清空
                    #         clean_flag = True
                    # if self.isAppear_top:
                    #     if r['st'] != 0:
                    #         dict['num'] = r['left_num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost']) + r['yingkui']
                    #         sold_type = 'isAppear_top'
                    #         self.trade_rec.update_one(condition, {
                    #             '$set': {'isSold': 1, 'left_num': 0, 'soldTime': str(curr_time),
                    #                      'soldPrice': curr_price, 'sold_type': sold_type,
                    #                      'yingkui': yingkui}})
                    #     else:
                    #         dict['num'] = r['num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost'])
                    #         sold_type = 'isAppear_top'
                    #         self.trade_rec.update_one(condition, {
                    #             '$set': {'isSold': 1, 'left_num': 0, 'soldTime': str(curr_time),
                    #                      'soldPrice': curr_price, 'sold_type': sold_type,
                    #                      'yingkui': yingkui}})
                    #
                    #         self.logger.info(
                    #             'sale_point: ' + str(r['code']) + '   ' + str(yingkui) + '   ' + str(curr_time))
                    #         # 如果有进来过那么，clean_flag 标记为清空
                    #         clean_flag = True

                    #
                    # elif latest_rec and latest_rec[0]['type'] == 'top' and latest_rec[0]['date'] == self.today and curr_price < self.yes1_lowest and curr_time.hour == 14 and curr_time.minute >= 55:
                    #     if r['st'] != 0:
                    #         dict['num'] = r['left_num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost']) + r['yingkui']
                    #         sold_type = 'top_beili'
                    #         self.trade_rec.update_one(condition, {
                    #             '$set': {'isSold': 1, 'left_num': 0, 'soldTime': str(curr_time),
                    #                      'soldPrice': curr_price, 'sold_type': sold_type,
                    #                      'yingkui': yingkui}})
                    #     else:
                    #         dict['num'] = r['num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost'])
                    #         sold_type = 'top_beili'
                    #         self.trade_rec.update_one(condition, {
                    #             '$set': {'isSold': 1, 'left_num': 0, 'soldTime': str(curr_time),
                    #                      'soldPrice': curr_price, 'sold_type': sold_type,
                    #                      'yingkui': yingkui}})
                    #
                    #         self.logger.info(
                    #             'sale_point: ' + str(r['code']) + '   ' + str(yingkui) + '   ' + str(curr_time))
                    #         # 如果有进来过那么，clean_flag 标记为清空
                    #         clean_flag = True

                    # 清空昨日出现top未卖出的仓位
                    # is_yes_top = self.beili.find_one({'code': r['code'], 'type':'top', 'date':self.yestoday})
                    # if is_yes_top:
                    #     if r['st'] != 0:
                    #         dict['num'] = r['left_num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost']) + r['yingkui']
                    #         sold_type = 'top_beili_yestoday_qingcang'
                    #         self.trade_rec.update_one(condition, {
                    #             '$set': {'isSold': 1, 'left_num': 0, 'soldTime': str(curr_time),
                    #                      'soldPrice': curr_price, 'sold_type': sold_type,
                    #                      'yingkui': yingkui}})
                    #     else:
                    #         dict['num'] = r['num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost'])
                    #         sold_type = 'top_beili_yestoday_qingcang'
                    #         self.trade_rec.update_one(condition, {
                    #             '$set': {'isSold': 1, 'left_num': 0, 'soldTime': str(curr_time),
                    #                      'soldPrice': curr_price, 'sold_type': sold_type,
                    #                      'yingkui': yingkui}})
                    #
                    #         self.logger.info(
                    #             'sale_point: ' + str(r['code']) + '   ' + str(yingkui) + '   ' + str(curr_time))
                    #         # 如果有进来过那么，clean_flag 标记为清空
                    #         clean_flag = True
                    #

                    # 如果是顶背离，或者出现假底部，那么卖出
                    # is_top_beili = (self.yes2_close >= self.yes1_close or self.yes2_lowest >= self.yes1_lowest or self.yes2_highest >= self.yes1_highest) and self.yes1_ma8 > curr_price and (
                    #                            self.yes1_ma7 > self.yes2_ma7 or self.yes1_ma6 > self.yes2_ma6 or self.yes1_ma8 > self.yes2_ma8)

                    # if is_top_beili:
                    #     sold_type = 'top_beili'

                    # if 'lowest_price' in latest_rec[0]:
                    #     is_false_bottom = (latest_rec and latest_rec[0]['type'] == 'bottom' and latest_rec[0]['lowest_price'] * 0.995 > curr_price)
                    #
                    #     if is_false_bottom:
                    #         sold_type = 'false_bottom'
                    #     if is_false_bottom:
                    #         dict['num'] = r['num']
                    #         condition = {'code': r['code'], '_id': r['_id']}
                    #         yingkui = dict['num'] * (curr_price - r['cost'])
                    #         self.trade_rec.update_one(condition, {'$set': {'isSold': 1, 'soldTime': str(curr_time), 'soldPrice': curr_price,
                    #                      'yingkui': yingkui, 'sold_type':sold_type}})
                    #
                    #         self.logger.info(
                    #             'sale_point: ' + str(r['code']) + '   ' + str(yingkui) + '   ' + str(curr_time))
                    #
                    #         # 如果有进来过那么，clean_flag 标记为清空
                    #         clean_flag = True

                if clean_flag:
                    self.catch_highest[r['code']] = pd.Series()

            except Exception as e:
                raise e
                self.logger.error(e)
                print('--------///错误///---------saleProcess 卖出错误:', e)

    def calculate_profit_one(self, code):

        # 获取昨日清仓盈利情况,昨日可能买了一笔，可能买了多笔
        hasSale = self.trade_rec.find({'code': code, 'isSold': 1})
        noSale = self.trade_rec.find({'code': code, 'isSold': 0})
        hasSale_yingkui = 0
        noSale_yingkui = 0
        sale_money = 0
        noSale_money = 0
        for y in hasSale:
            hasSale_yingkui += y['yingkui']
            sale_money += y['money']
        for k in noSale:
            noSale_yingkui += k['yingkui']
            noSale_money += k['money']

        # 更新到总表里
        total_yingkui = noSale_yingkui + hasSale_yingkui

        if total_yingkui + noSale_money == 0:
            acc_rate = 0
        else:
            acc_rate = round(total_yingkui / (total_yingkui + noSale_money), 2)

        dict = {'code': code, 'date': self.today, 'yingkui': total_yingkui, 'Acc_rate': acc_rate,
                'noSale_money': noSale_money, 'sale_money': sale_money}

        self.fd[self.file_name + 'noSale_money'].insert_one(dict)

    def calculate_profit(self):

        # 获取昨日清仓盈利情况,昨日可能买了一笔，可能买了多笔
        hasSale = self.trade_rec.find({'isSold': 1})
        noSale = self.trade_rec.find({'isSold': 0})
        hasSale_yingkui = 0
        noSale_yingkui = 0
        sale_money = 0
        noSale_money = 0
        for y in hasSale:
            hasSale_yingkui += y['yingkui']
            sale_money += y['money']
        for k in noSale:
            noSale_yingkui += k['yingkui']
            noSale_money += k['money']

        # 更新到总表里
        total_yingkui = noSale_yingkui + hasSale_yingkui

        if total_yingkui + noSale_money == 0:
            acc_rate = 0
        else:
            acc_rate = round(total_yingkui / (total_yingkui + noSale_money), 2)

        dict = {'date': self.today, 'yingkui': total_yingkui, 'Acc_rate': acc_rate, 'noSale_money': noSale_money,
                'sale_money': sale_money}

        file_path = './' + self.file_name + '_log.xlsx'
        if os.path.exists(file_path):
            df_res = pd.read_excel(file_path)
            df_res = df_res.append(dict, ignore_index=True)
            # os.remove(file_path)
            df_res.to_excel(file_path)
        else:
            df = pd.DataFrame(columns=['date', 'yingkui', 'Acc_rate', 'noSale_money', 'sale_money'])
            df = df.append(dict, ignore_index=True)
            df.to_excel(file_path)

        self.logger.info(
            str(self.today) + ' 总盈亏：' + str(total_yingkui) + 'Acc_rate' + str(acc_rate) + ' 未卖出金额：' + str(
                noSale_money) + ' 已卖出金额：' + str(sale_money))

    def __del__(self):
        del self.logger


def drop_coll():
    today = '2021-07-01'
    yestoday = '2021-06-31'
    etf = ETF(yestoday, today)

    etf.fd.drop_collection(etf.file_name + 'trade_rec')
    etf.fd.drop_collection(etf.file_name + '_beili')
    etf.fd.drop_collection(etf.file_name + 'hasBuy')
    etf.fd.drop_collection(etf.file_name + 'noSale_money')

    path = './' + etf.file_name + '_log.xlsx'  # 文件路径
    if os.path.exists(path):  # 如果文件存在
        os.remove(path)
    path = './' + etf.file_name + '_beili.xlsx'  # 文件路径
    if os.path.exists(path):  # 如果文件存在
        os.remove(path)
    path = './' + etf.file_name + '_hasbuy.xlsx'  # 文件路径
    if os.path.exists(path):  # 如果文件存在
        os.remove(path)
    path = './' + etf.file_name + '_trade.xlsx'  # 文件路径
    if os.path.exists(path):  # 如果文件存在
        os.remove(path)


def back_test(test_list, yestoday, today):
    etf = ETF(yestoday, today)
    for code in test_list:
        try:
            trade_info = pd.read_excel('./data/new_rebuild/' + code[2:] + '/' + today + '.xlsx')
            # 获取当日ma5, ma10
            code_df = pd.read_excel('./data/new_rebuild/' + code[2:] + '/' + code[2:] + '.xlsx')
            etf.get_ma(code_df)

        except Exception as e:
            print(e)
        else:
            for info in trade_info.iterrows():
                ser = pd.Series()
                if code[2] == '5':
                    head_str = 'SSE.'
                else:
                    head_str = 'SZSE.'
                lastreq = {
                    'code': code,
                    'curr_price': info[1][head_str + code[2:] + '.last_price'],
                    'today_highest': info[1][head_str + code[2:] + '.highest'],
                    'today_lowest': info[1][head_str + code[2:] + '.lowest'],
                }
                ser[code] = info[1][head_str + code[2:] + '.last_price']
                curr_time = datetime.datetime.strptime(info[1]['datetime'][0:19], '%Y-%m-%d %H:%M:%S')
                if pd.isna(lastreq['curr_price']):
                    # etf.logger.debug(info[1])
                    continue
                etf.jk_buy(curr_time, ser, lastreq)
                etf.jk_sale(curr_time, ser, lastreq)

            # 获取最近插入的数据
            etf.beili = etf.fd[etf.file_name + '_beili']
            latest_rec = etf.beili.find({'code': code}).sort('_id', -1).limit(2)
            latest_rec = [x for x in latest_rec]
            if latest_rec:
                trade_days = latest_rec[0]['trade_days'] + 1
                etf.beili.update_one({'code': code, 'date': latest_rec[0]['date'], '_id': latest_rec[0]['_id']},
                                     {'$set': {'trade_days': trade_days}})
                # 如果是第一天bottom，那么还要更新当日最低价格，因为次日很容易就低于了bottom时候的记录价格，造成false_bottom卖出
                if trade_days == 1:
                    etf.beili.update_one({'code': code, 'date': latest_rec[0]['date'], '_id': latest_rec[0]['_id']},
                                         {'$set': {'lowest_price': lastreq['today_lowest']}})
                    etf.logger.critical(
                        f"'code': {code}, 'date': {latest_rec[0]['date']},'lowest_price': {lastreq['today_lowest']}")

            # # 查找今日是否有假背离卖出
            # sold_today = etf.trade_rec.find_one({'code':code,'date':today})
            # if sold_today and sold_today['sold_type'] == 'top_beili' and latest_rec[0]['type'] == 'bottom':
            #     etf.trade_rec.find_one_and_update({'code':code,'date':today},{'$set': {'isTrue_beili': 'false'}})
            # else:
            #     etf.trade_rec.find_one_and_update({'code':code,'date':today},{'$set': {'isTrue_beili': 'true'}})

            cost = 0
            num = 0
            buyMoney = 0
            hasBuy = etf.hasBuy.find({'code': code, 'buy_date': today})
            bts = 0
            for h in hasBuy:
                num += h['num']
                buyMoney += h['money']
                bts += 1
            if num != 0:
                cost = round(buyMoney / num, 4)
                if len(latest_rec) == 2:
                    etf.trade_rec.insert_one(
                        {'code': code, 'price': cost, 'time': str(curr_time), 'buy_date': etf.today, 'bt': 1,
                         'money': buyMoney, 'isSold': 0, 'cost': cost, 'num': num, 'pct_bt': 0,
                         'yingkui': 0, 'yingkui1': 0, 'yingkui2': 0, 'yingkui3': 0, 'left_num': num, 'bts': bts,
                         'trade_days': trade_days, 'pre_trade_days': latest_rec[1]['trade_days'], 'st': 0, 'highest_price':cost})
                elif len(latest_rec) == 1:
                    etf.trade_rec.insert_one(
                        {'code': code, 'price': cost, 'time': str(curr_time), 'buy_date': etf.today, 'bt': 1,
                         'money': buyMoney, 'isSold': 0, 'cost': cost, 'num': num, 'pct_bt': 0,
                         'yingkui': 0, 'yingkui1': 0, 'yingkui2': 0, 'yingkui3': 0, 'left_num': num, 'bts': bts,
                         'trade_days': trade_days, 'pre_trade_days': 0, 'st': 0, 'highest_price':cost})

            etf.calculate_profit_one(code)

    # etf.calculate_profit()
    del etf


if __name__ == '__main__':

    # 获取交易数据
    today = '2021-01-04'
    yestoday = '2021-01-03'

    etf = ETF(yestoday, today)


    drop_coll()
    time.sleep(3)
    all_etf = ['sz159982', 'sz159845', 'sh515030', 'sh516110', 'sz159755', 'sh516020', 'sh516570',
               'sh516220', 'sz159930', 'sh515210', 'sh512880', 'sh512800', 'sh516310', 'sh512960',
               'sh512950', 'sz159861', 'sh515220', 'sh516780', 'sh510410', 'sh515080', 'sh515180',
               'sh510880', 'sz159990', 'sh516950', 'sz159825', 'sz159995', 'sz159915', 'sz159949',
               'sh510330', 'sh588050', 'sh512660', 'sh515170', 'sh515790', 'sh512980', 'sz159996',
               'sz159852', 'sh516010']

    trade_date = {
        1: ['2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-11', '2021-01-12',
            '2021-01-13',
            '2021-01-14', '2021-01-15', '2021-01-18', '2021-01-19', '2021-01-20', '2021-01-21', '2021-01-22',
            '2021-01-25',
            '2021-01-26', '2021-01-27', '2021-01-28', '2021-01-29'],
        2: ['2021-02-01', '2021-02-02', '2021-02-03', '2021-02-04', '2021-02-05', '2021-02-08', '2021-02-09',
            '2021-02-10',
            '2021-02-18', '2021-02-19', '2021-02-22', '2021-02-23', '2021-02-24', '2021-02-25', '2021-02-26'],
        3: ['2021-03-01', '2021-03-02', '2021-03-03', '2021-03-04', '2021-03-05', '2021-03-08', '2021-03-09',
            '2021-03-10',
            '2021-03-11', '2021-03-12', '2021-03-15', '2021-03-16', '2021-03-17', '2021-03-18', '2021-03-19',
            '2021-03-22',
            '2021-03-23', '2021-03-24', '2021-03-25', '2021-03-26', '2021-03-29', '2021-03-30', '2021-03-31'],
        4: ['2021-04-01', '2021-04-02', '2021-04-06', '2021-04-07', '2021-04-08', '2021-04-09', '2021-04-12',
            '2021-04-13',
            '2021-04-14', '2021-04-15', '2021-04-16', '2021-04-19', '2021-04-20', '2021-04-21', '2021-04-22',
            '2021-04-23',
            '2021-04-26', '2021-04-27', '2021-04-28', '2021-04-29', '2021-04-30'],
        5: ['2021-05-06', '2021-05-07', '2021-05-10', '2021-05-11', '2021-05-12', '2021-05-13', '2021-05-14',
            '2021-05-17',
            '2021-05-18', '2021-05-19', '2021-05-20', '2021-05-21', '2021-05-24', '2021-05-25', '2021-05-26',
            '2021-05-27',
            '2021-05-28', '2021-05-31'],
        6: ['2021-06-01', '2021-06-02', '2021-06-03', '2021-06-04', '2021-06-07', '2021-06-08', '2021-06-09',
            '2021-06-10',
            '2021-06-11', '2021-06-15', '2021-06-16', '2021-06-17', '2021-06-18', '2021-06-21', '2021-06-22',
            '2021-06-23',
            '2021-06-24', '2021-06-25', '2021-06-28', '2021-06-29', '2021-06-30'],
        7: ['2021-07-01', '2021-07-02', '2021-07-05', '2021-07-06', '2021-07-07', '2021-07-08', '2021-07-09',
            '2021-07-12',
            '2021-07-13', '2021-07-14', '2021-07-15', '2021-07-16', '2021-07-19', '2021-07-20', '2021-07-21',
            '2021-07-22',
            '2021-07-23', '2021-07-26', '2021-07-27', '2021-07-28', '2021-07-29', '2021-07-30'],
        8: ['2021-08-02', '2021-08-03', '2021-08-04', '2021-08-05', '2021-08-06', '2021-08-09', '2021-08-10',
            '2021-08-11',
            '2021-08-12', '2021-08-13', '2021-08-16', '2021-08-17', '2021-08-18', '2021-08-19', '2021-08-20',
            '2021-08-23',
            '2021-08-24', '2021-08-25', '2021-08-26', '2021-08-27', '2021-08-30', '2021-08-31'],
        9: ['2021-09-01', '2021-09-02', '2021-09-03', '2021-09-06', '2021-09-07', '2021-09-08', '2021-09-09',
            '2021-09-10',
            '2021-09-13', '2021-09-14', '2021-09-15', '2021-09-16', '2021-09-17', '2021-09-22', '2021-09-23',
            '2021-09-24',
            '2021-09-27', '2021-09-28', '2021-09-29', '2021-09-30'],
        10: ['2021-10-08', '2021-10-11', '2021-10-12', '2021-10-13', '2021-10-14', '2021-10-15', '2021-10-18',
             '2021-10-19', '2021-10-20', '2021-10-21', '2021-10-22', '2021-10-25', '2021-10-26', '2021-10-27',
             '2021-10-28', '2021-10-29'],
        11: ['2021-11-01', '2021-11-02', '2021-11-03', '2021-11-04', '2021-11-05', '2021-11-08', '2021-11-09',
             '2021-11-10', '2021-11-11', '2021-11-12', '2021-11-15', '2021-11-16', '2021-11-17', '2021-11-18',
             '2021-11-19', '2021-11-22', '2021-11-23', '2021-11-24', '2021-11-25', '2021-11-26', '2021-11-29',
             '2021-11-30'],
        12: ['2021-12-01', '2021-12-02', '2021-12-03', '2021-12-06', '2021-12-07', '2021-12-08', '2021-12-09',
             '2021-12-10', '2021-12-13', '2021-12-14', '2021-12-15', '2021-12-16', '2021-12-17', '2021-12-20',
             '2021-12-21', '2021-12-22', '2021-12-23', '2021-12-24', '2021-12-27', '2021-12-28', '2021-12-29',
             '2021-12-30', '2021-12-31']}

    trade_date_list = []
    for t in range(1, 13):
        trade_date_list += trade_date[t]

    for index, today in enumerate(trade_date_list[0:]):
        # 前5天不买
        if index <= 13:
            continue
        print('index,today', index, today)
        print("***************************************************************************************")
        # today = today
        if today == '2021-01-04':
            yestoday = '2021-01-03'
        else:
            yestoday = trade_date_list[index - 1]

        pdict = {}
        for code in all_etf[0:]:
            if code not in ['sh512660']:
                continue
            p = Process(target=back_test, args=([code], yestoday, today))
            pdict[code] = p
            print(pdict[code])
            p.start()
        for p in pdict.values():
            p.join()

        for p in pdict.values():
            p.kill()

        # 获取当前执行文件的名称
        file_name = str(os.path.basename(__file__).split('.')[0])

        etf = ETF(yestoday, today)
        res_nosale_money = etf.fd[file_name + 'noSale_money'].find({'date': today})

        today_nosale_money = 0
        today_sale_money = 0
        today_today_yingkui = 0
        for r in res_nosale_money:
            today_nosale_money += r['noSale_money']
            today_sale_money += r['sale_money']
            today_today_yingkui += r['yingkui']

        res_nosale_money = etf.fd[file_name + 'noSale_money'].find({'date': today})
        for r in res_nosale_money:
            etf.fd[file_name + 'noSale_money'].update_one({'code': r['code'], 'date': today},{'$set':{'today_noSale_money': today_nosale_money, 'today_sale_money': today_sale_money, 'today_today_yingkui':today_today_yingkui}})

        del etf

    # 获取当前执行文件的名称
    file_name = str(os.path.basename(__file__).split('.')[0])

    trade_date = {
        1: ['2021-01-04', '2021-01-05', '2021-01-06', '2021-01-07', '2021-01-08', '2021-01-11', '2021-01-12',
            '2021-01-13',
            '2021-01-14', '2021-01-15', '2021-01-18', '2021-01-19', '2021-01-20', '2021-01-21', '2021-01-22',
            '2021-01-25',
            '2021-01-26', '2021-01-27', '2021-01-28', '2021-01-29'],
        2: ['2021-02-01', '2021-02-02', '2021-02-03', '2021-02-04', '2021-02-05', '2021-02-08', '2021-02-09',
            '2021-02-10',
            '2021-02-18', '2021-02-19', '2021-02-22', '2021-02-23', '2021-02-24', '2021-02-25', '2021-02-26'],
        3: ['2021-03-01', '2021-03-02', '2021-03-03', '2021-03-04', '2021-03-05', '2021-03-08', '2021-03-09',
            '2021-03-10',
            '2021-03-11', '2021-03-12', '2021-03-15', '2021-03-16', '2021-03-17', '2021-03-18', '2021-03-19',
            '2021-03-22',
            '2021-03-23', '2021-03-24', '2021-03-25', '2021-03-26', '2021-03-29', '2021-03-30', '2021-03-31'],
        4: ['2021-04-01', '2021-04-02', '2021-04-06', '2021-04-07', '2021-04-08', '2021-04-09', '2021-04-12',
            '2021-04-13',
            '2021-04-14', '2021-04-15', '2021-04-16', '2021-04-19', '2021-04-20', '2021-04-21', '2021-04-22',
            '2021-04-23',
            '2021-04-26', '2021-04-27', '2021-04-28', '2021-04-29', '2021-04-30'],
        5: ['2021-05-06', '2021-05-07', '2021-05-10', '2021-05-11', '2021-05-12', '2021-05-13', '2021-05-14',
            '2021-05-17',
            '2021-05-18', '2021-05-19', '2021-05-20', '2021-05-21', '2021-05-24', '2021-05-25', '2021-05-26',
            '2021-05-27',
            '2021-05-28', '2021-05-31'],
        6: ['2021-06-01', '2021-06-02', '2021-06-03', '2021-06-04', '2021-06-07', '2021-06-08', '2021-06-09',
            '2021-06-10',
            '2021-06-11', '2021-06-15', '2021-06-16', '2021-06-17', '2021-06-18', '2021-06-21', '2021-06-22',
            '2021-06-23',
            '2021-06-24', '2021-06-25', '2021-06-28', '2021-06-29', '2021-06-30'],
        7: ['2021-07-01', '2021-07-02', '2021-07-05', '2021-07-06', '2021-07-07', '2021-07-08', '2021-07-09',
            '2021-07-12',
            '2021-07-13', '2021-07-14', '2021-07-15', '2021-07-16', '2021-07-19', '2021-07-20', '2021-07-21',
            '2021-07-22',
            '2021-07-23', '2021-07-26', '2021-07-27', '2021-07-28', '2021-07-29', '2021-07-30'],
        8: ['2021-08-02', '2021-08-03', '2021-08-04', '2021-08-05', '2021-08-06', '2021-08-09', '2021-08-10',
            '2021-08-11',
            '2021-08-12', '2021-08-13', '2021-08-16', '2021-08-17', '2021-08-18', '2021-08-19', '2021-08-20',
            '2021-08-23',
            '2021-08-24', '2021-08-25', '2021-08-26', '2021-08-27', '2021-08-30', '2021-08-31'],
        9: ['2021-09-01', '2021-09-02', '2021-09-03', '2021-09-06', '2021-09-07', '2021-09-08', '2021-09-09',
            '2021-09-10',
            '2021-09-13', '2021-09-14', '2021-09-15', '2021-09-16', '2021-09-17', '2021-09-22', '2021-09-23',
            '2021-09-24',
            '2021-09-27', '2021-09-28', '2021-09-29', '2021-09-30'],
        10: ['2021-10-08', '2021-10-11', '2021-10-12', '2021-10-13', '2021-10-14', '2021-10-15', '2021-10-18',
             '2021-10-19', '2021-10-20', '2021-10-21', '2021-10-22', '2021-10-25', '2021-10-26', '2021-10-27',
             '2021-10-28', '2021-10-29'],
        11: ['2021-11-01', '2021-11-02', '2021-11-03', '2021-11-04', '2021-11-05', '2021-11-08', '2021-11-09',
             '2021-11-10', '2021-11-11', '2021-11-12', '2021-11-15', '2021-11-16', '2021-11-17', '2021-11-18',
             '2021-11-19', '2021-11-22', '2021-11-23', '2021-11-24', '2021-11-25', '2021-11-26', '2021-11-29',
             '2021-11-30'],
        12: ['2021-12-01', '2021-12-02', '2021-12-03', '2021-12-06', '2021-12-07', '2021-12-08', '2021-12-09',
             '2021-12-10', '2021-12-13', '2021-12-14', '2021-12-15', '2021-12-16', '2021-12-17', '2021-12-20',
             '2021-12-21', '2021-12-22', '2021-12-23', '2021-12-24', '2021-12-27', '2021-12-28', '2021-12-29',
             '2021-12-30', '2021-12-31']}

    trade_date_list = []
    for t in range(1, 13):
        trade_date_list += trade_date[t]

    today = '2021-01-04'
    yestoday = '2021-01-03'

    etf = ETF(yestoday, today)

    # 获取noSale_money情况
    total_df = pd.DataFrame(columns=('date', 'yingkui', 'Acc_rate', 'sale_money', 'noSale_money'))
    for d in trade_date_list:
        null_dict = {'date': '', 'yingkui': 0, 'Acc_rate': 0, 'sale_money': 0, 'noSale_money': 0}
        res = etf.fd[etf.file_name + 'noSale_money'].find({'date': d})
        for r in res:
            null_dict['yingkui'] += r['yingkui']
            null_dict['sale_money'] += r['sale_money']
            null_dict['noSale_money'] += r['noSale_money']
        null_dict['date'] = d
        if null_dict['sale_money'] != 0 and null_dict['noSale_money'] != 0:
            null_dict['Acc_rate'] = null_dict['yingkui'] / (null_dict['yingkui'] + null_dict['noSale_money'])
        else:
            null_dict['Acc_rate'] = 0

        total_df = total_df.append(null_dict, ignore_index=True)

    total_df.to_excel('./' + file_name + '_log.xlsx')

    res_trade_info = etf.trade_rec.find()
    total_trade_df = pd.DataFrame(columns=(
    'code', 'price', 'time', 'buy_date', 'isSold', 'cost', 'num', 'pct_bt', 'yingkui', 'isReckon', 'soldPrice',
    'soldTime'))
    for r in res_trade_info:
        r.pop('_id')
        total_trade_df = total_trade_df.append(r, ignore_index=True)

    total_trade_df.to_excel('./' + file_name + '_trade.xlsx')

    # 获取背离情况
    etf.beili = etf.fd[file_name + '_beili']
    res_beili = etf.beili.find()
    total_beili_df = pd.DataFrame(columns=('code', 'type', 'price', 'trade_state', 'trade_days', 'date', 'time'))
    for r in res_beili:
        r.pop('_id')
        total_beili_df = total_beili_df.append(r, ignore_index=True)

    total_beili_df.to_excel('./' + file_name + '_beili.xlsx')

    # 获取hasbuy买明细
    total_hasbuy_df = pd.DataFrame()
    res_hasbuy = etf.hasBuy.find()
    for r in res_hasbuy:
        r.pop('_id')
        total_hasbuy_df = total_hasbuy_df.append(r, ignore_index=True)

    total_hasbuy_df.to_excel('./' + file_name + '_hasbuy.xlsx')

    #获取nosale 明细
    detail_nosale_info = pd.DataFrame()
    res_nosale = etf.fd[etf.file_name + 'noSale_money'].find()
    for r in res_nosale:
        r.pop('_id')
        detail_nosale_info = detail_nosale_info.append(r, ignore_index=True)

    detail_nosale_info.to_excel('./' + file_name + '_nosale_detail.xlsx')

"""
1、减少止损金额
2、引入当前curr_ma5,6，7,8来判断top，尝试提高灵敏度
3、引入了macd，
4、wrong_bottom比较多，尝试规避这种情况，如果当日出现bottom不买，次日才买！！！？？？（可否换成如果macd或者波动指标adx来确定buymoney）
5、使用macd来控制bumoney
6、如果macd 在-0.011到0.011之间，那么4，5不买，1，2，3翻倍，做横盘T，并且增大当日超额买入金额限额， 解决超过self.money2 * 4问题

"""
